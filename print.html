<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Smithay Handbook</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="client/intro.html"><strong aria-hidden="true">1.</strong> Wayland apps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/general/intro.html"><strong aria-hidden="true">1.1.</strong> General principles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/general/objects.html"><strong aria-hidden="true">1.1.1.</strong> Objects</a></li><li class="chapter-item expanded "><a href="client/general/event_queues.html"><strong aria-hidden="true">1.1.2.</strong> Event queues and filters</a></li><li class="chapter-item expanded "><a href="client/general/initializing.html"><strong aria-hidden="true">1.1.3.</strong> Initializing an app</a></li><li class="chapter-item expanded "><a href="client/general/registry.html"><strong aria-hidden="true">1.1.4.</strong> The registry and globals</a></li></ol></li><li class="chapter-item expanded "><a href="client/sctk/intro.html"><strong aria-hidden="true">1.2.</strong> Getting started with SCTK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/sctk/environment.html"><strong aria-hidden="true">1.2.1.</strong> The Environment</a></li><li class="chapter-item expanded "><a href="client/sctk/window.html"><strong aria-hidden="true">1.2.2.</strong> Creating a Window</a></li><li class="chapter-item expanded "><a href="client/sctk/drawing.html"><strong aria-hidden="true">1.2.3.</strong> Drawing to a Window</a></li><li class="chapter-item expanded "><a href="client/sctk/image_viewer.html"><strong aria-hidden="true">1.2.4.</strong> Exercice: an image viewer</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.</strong> Processing user input</li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">1.3.1.</strong> The seats</li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.2.</strong> Pointers</li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.3.</strong> Keyboards</li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.4.</strong> Touchscreens</li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">1.4.</strong> Multiple outputs and HiDPI</li><li class="chapter-item expanded "><strong aria-hidden="true">1.5.</strong> Cliboard and Drag'n'Drop</li><li class="chapter-item expanded "><strong aria-hidden="true">1.6.</strong> Drawing with OpenGL</li></ol></li><li class="chapter-item expanded "><a href="server/intro.html"><strong aria-hidden="true">2.</strong> Wayland Compositors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Smithay Handbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the Smithay Handbook.</p>
<p>This is a work in progress, and intended to serve as a general manual for building Wayland-related
software in Rust, using the tools from the <a href="https://smithay.github.io/">Smithay project</a>.</p>
<p>The project revolves around 3 main components:</p>
<ul>
<li>The <a href="https://github.com/Smithay/wayland-rs">wayland-rs</a> repository contains low-level bindings to the
Wayland protocols, under the form of several crates. The two most notable being
<a href="https://crates.io/crates/wayland-client"><code>wayland-client</code></a> and
<a href="https://crates.io/crates/wayland-server"><code>wayland-server</code></a>, which are the core bindings for client-side
and server-side apps.</li>
<li><a href="https://crates.io/crates/smithay-client-toolkit">SCTK</a>, or Smithay Client ToolKit, is a crate designed
to handle a significant portion of the plumbing required for writing Wayland client apps. It comes on top
of wayland-client, and this book will present it as well.</li>
<li><a href="https://github.com/Smithay/smithay">Smithay</a> is the flagship crate of the project, and is designed as
a framework for writing Wayland servers (also called compositors). It is built on top of the wayland-server
crate, and also handles most of the interaction with the system (input devices, graphics, udev, sessions, ...).</li>
</ul>
<p>The first part of this book is dedicated to client-side apps, while the second part focuses of server-side.
If you are interested by the server-side stuff, it is recommended to first get familiar with the client-side,
as it is easier to get into and a lot of its concepts map to server-side.</p>
<h1><a class="header" href="#wayland-apps" id="wayland-apps">Wayland apps</a></h1>
<p>This part of the book is dedicated to Wayland client apps, so writing programs that can run in
a Wayland environment: display something to the screen, receive user input and process it. This
include classic apps wich display a window with their content, but can also include programs such
as desktop components (widgets, bars, animated backgrounds, lockscreens, ...).</p>
<p>The first section will be dedicated to general principles of the wayland protocol, as well as the
main objects of the <a href="https://crates.io/crates/wayland-client">wayland-client</a> crate. The following
sections will explore in more details the actual process of writing an app.</p>
<h1><a class="header" href="#general-principles" id="general-principles">General principles</a></h1>
<p>The Wayland protocol follows a client-server architecture: the Wayland compositor listens
on an UNIX socket, to which client apps then connect in order to present their graphical
interface. This UNIX connection transports information in both directions: the client uses
it to tell the server what it wants to display, and the server uses it to tell the client
about user actions (such as keyboard or pointer input). The Wayland connection is thus the
heart of a client app, and is the source of events that drives its event loop.</p>
<p>The server tells to clients about the Wayland socket using the <code>WAYLAND_DISPLAY</code> environment
variable. The listening socket is placed at <code>$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY</code>. This will
typically be a path like <code>/run/user/1000/wayland-0</code>.</p>
<p>When starting your app, it will need to find the Wayland socket and connect to it. The
wayland-client crate does this for you with the
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.Display.html#method.connect_to_env"><code>Display::connect_to_env()</code></a>
method. If no error occurs, this function will provide you with a <code>Display</code> object.</p>
<p>This object is the very heart of your Wayland program. It represents your connection to the
server, and this is from this object that everything will be further initialized. But to
understand how this objects relates to the rest of the crate, we will first need to get a
better understanding of the distinction between the protocol objects, and the Rust structs that
your program will manipulate.</p>
<h1><a class="header" href="#objects" id="objects">Objects</a></h1>
<p>The Wayland protocol is an object-oriented protocol. This means that, as the client and
server exchange messages, they build an abstract state made of several objects, which
are represented by a numeric identifier. You can figure them as being scopes for messages:
each message is associated with one of these protocol object. Each object has an &quot;interface&quot;,
which is a definition of which messages can be associated with it.</p>
<p>The messages are named &quot;requests&quot; when they are sent by the client to the server, and &quot;events&quot;
when they are sent by the server to the client. An object interface is thus the list of which
requests and which events can be associated with objects of this interface.</p>
<p>For example, an object representing a keyboard would receive the events from the server informing
about which keys are pressed by the user. An object representing a window would send requests
to update its content, and receive events informing about user interaction (such as resizing).</p>
<p>At the beginning, the protocol state contains a single object. Its identifier is 1, and its
interface is <code>wl_display</code>. This is from it that the rest of the protocol state is setup by
the client.</p>
<h2><a class="header" href="#objects-and-proxies" id="objects-and-proxies">Objects and proxies</a></h2>
<p>The protocol objects are created and destroyed by messages. A request sent by the client can
have for effect the creation of a new object in the state, or the destruction of an object.
Most of the time, creation and destruction of objects is done by the client, but there are
exceptions. For this reason, protocol objects are not directly represented by Rust structs,
but instead one layer of indirection is added. <code>wayland-client</code> provides you with Rust objects
that we call &quot;proxies&quot;.</p>
<p>Each proxy represents a protocol object, but several proxies can represent the same object. You
can think of proxies as something akin <code>Rc&lt;_&gt;</code> or <code>Arc&lt;_&gt;</code>: they are an handle to the underlying
protocol object. Furthermore, their lifetime is not tied to the protocol object's lifetime: they
can outlive it. Once a protocol object has been destroyed, the proxies associated to it will
become inert.</p>
<h2><a class="header" href="#the-4-forms-of-a-proxy" id="the-4-forms-of-a-proxy">The 4 forms of a proxy</a></h2>
<p>A proxy for a protocol object can be manipulated under four forms:</p>
<ul>
<li>As direct proxy, as a bare Wayland type, something like <code>WlFoo</code>. This form is the
closest to the protocol object, and its methods map to the requests of the interface of
this object.</li>
<li>As a <code>Proxy&lt;WlFoo&gt;</code>. In this form, you can manipulate the proxy as a proxy, rather than
as a protocol object. This lets you do things like check if the underlying object is still
alive, retrieve its ID, or access the user data associated with it (see below).</li>
<li>As an <code>Attached&lt;WlFoo&gt;</code>. This form is very similar to the bare <code>WlFoo</code>, but it additionnaly
allows you to send requests that create new objects (doing so with a bare <code>WlFoo</code> will panic).</li>
<li>As a <code>Main&lt;WlFoo&gt;</code>. This form is similar to <code>Attached&lt;WlFoo&gt;</code>, but additionnaly allows you to
change the event handler associated with the Wayland object.</li>
</ul>
<p>We will soon explain the role of event handlers and <code>Main&lt;_&gt;</code> and <code>Attached&lt;_&gt;</code> proxies in the
context of event queues, but before that, a quick word about user data.</p>
<h2><a class="header" href="#user-data" id="user-data">User data</a></h2>
<p><code>wayland-client</code> makes it possible to associate some data with a protocol object, via the
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.Proxy.html#method.user_data"><code>Proxy&lt;_&gt;::user_data()</code></a>
method. This method gives you access to a <code>&amp;UserData</code> value, which holds the associated data.
The important part is that <em>all proxies associated to the same protocol object give you access
to the same <code>&amp;UserData</code></em>. The value you associate with it is thus attached to the protocol
object, rather than the proxy. This mechanism is largely used accross wayland apps, as it is
not rare to have several proxies for the same object.</p>
<p>The <a href="https://docs.rs/wayland-client/*/wayland_client/struct.UserData.html"><code>UserData</code></a> type is a
set-once style container: you can only set its value once, and then you can get a <code>&amp;</code>-reference
to its contents provided you know the type of the stored value. If you need the associated data
to be mutable, you need to handle interior-mutability (by storing a <code>RefCell</code> or a <code>Mutex</code> for
example).</p>
<p>Lets now discuss event queues.</p>
<h1><a class="header" href="#event-queues-and-filters" id="event-queues-and-filters">Event queues and filters</a></h1>
<p>If the <a href="https://docs.rs/wayland-client/*/wayland_client/struct.Display.html"><code>Display</code></a> is the heart of your Wayland app, the <a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a> will be its
backbone. As described in the previous section, messages are sent in both directions,
and so far we only discussed how to send requests (using the methods of bare proxies),
but not how to receive events. This is done via event queues and callbacks.</p>
<h2><a class="header" href="#event-callbacks" id="event-callbacks">Event callbacks</a></h2>
<p>Each protocol object can be assigned to a callback, which will be invoked whenever
this object receives an event. The event callback receives 3 arguments:</p>
<ul>
<li>a <code>Main&lt;_&gt;</code> proxy to the object this event is associated to</li>
<li>a the event itself, under the form of the <code>Event</code> enum of the interface of this object</li>
<li>a mutable reference to the <code>DispatchData</code>, which is some global mutable state shared
by the event queue (we will get into details about that when explaining the event queue)</li>
</ul>
<p>This callback should then contain the logic of your program for handling this event. This
may require anything from just storing the new information somewhere to process it later,
to directly responding to the server by sending a request, from within the callback.</p>
<p>The direct way to assign a callback to an object is via the 
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.Main.html#method.quick_assign"><code>Main&lt;_&gt;::quick_assign()</code></a>
method, which requires to be given a callback under the form of an <code>FnMut</code> closure. You can
thus capture values in the callback, but it must be a <code>'static</code> closure, so it cannot
capture references, only values (this implies it must be a <code>move</code> closure if it captures
anything).</p>
<p>An alternative approach is to use a <a href="https://docs.rs/wayland-client/*/wayland_client/struct.Filter.html"><code>Filter</code></a>. You can think of filters as a <code>Rc&lt;_&gt;</code> wrapper
around a closure. Filters allow you to use the same closure to process events from several
objects, making state sharing easier. They are a more advanced use, and we shall come back to
them later.</p>
<h2><a class="header" href="#event-queues-and-attached-proxies" id="event-queues-and-attached-proxies">Event queues and Attached proxies</a></h2>
<p><a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a>s are the type which actually read events from the Wayland socket, and
invoke your appropriate callbacks. All protocol objects are associated at creation to an
event queue so that their events are processed.</p>
<p>This is where the <code>Attached&lt;_&gt;</code> proxies come into play. Given a <code>Proxy&lt;_&gt;</code>, you can attach
it to an <a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a> like so, using a event queue token:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let attached_proxy = proxy.attach(&amp;event_queue.token());
<span class="boring">}
</span></code></pre></pre>
<p>Attaching a proxy only affects the proxy, not the protocol object. The effect is that whenever
a request is sent that creates a new object, this newly created object will be associated to
the event queue to which its creator proxy is attached. Given an object must always be associated
with an event queue, requests creating new object are thus only allowed from <code>Attached&lt;_&gt;</code>
proxies. <code>Main&lt;_&gt;</code> proxies behave like <code>Attached&lt;_&gt;</code> ones, being attached to the same queue
as the one the underlying object is associated to. Creating new objects directly from the
same event queue as their parent object is by far the most frequent case.</p>
<p><a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a>s are cannot be shared between threads (they are <code>!Send</code> and <code>!Sync</code>),
this mechanism thus allow to associate different objects to different queues, and
potentially different threads, and is required for handling that in a threadsafe way.
Following that, <code>Attached&lt;WlFoo&gt;</code> and <code>Main&lt;WlFoo&gt;</code> are not <code>Send</code> either, while
<code>WlFoo</code> and <code>Proxy&lt;WlFoo&gt;</code> are.</p>
<h2><a class="header" href="#dispatching-event-queues" id="dispatching-event-queues">Dispatching event queues</a></h2>
<p>To receive events, it is necessary to read the Wayland socket and call the appropriate callbacks.
We call this process &quot;dispatching&quot;, and as <code>wayland-client</code> does not take the control-flow away
from you, you need to tell it to do it.</p>
<p>The simplest way to achieve that is with the
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html#method.dispatch"><code>EventQueue::dispatch()</code></a>
method. This method does 3 things:</p>
<ul>
<li>Flush the outgoing buffer (when sending a request, it is not directly written to the socket but instead
buffered, to improve performance)</li>
<li>Read pending events from the socket, if none are available block until some are received, and distribute
these events to the internal buffer of their target event queue</li>
<li>Empty the internal buffer of the event queue on which the method was called by invoking the appropriate
callbacks</li>
</ul>
<p>This method also requires you to provide two additional arguments:</p>
<ul>
<li>A mutable reference to some value <code>&amp;mut T</code>: this reference is accessible from all callbacks invoked by this
event queue as the <code>&amp;mut DispatchData</code> argument. If they wish to use it, the callbacks need to handle the
downcasting using the methods provided by <a href="https://docs.rs/wayland-client/*/wayland_client/struct.DispatchData.html"><code>DispatchData</code></a>, in a similar fashion as <code>Any</code>. This value is
typically used to serve as the global state of your app.</li>
<li>A fallback closure. This closure will be invoked for all events associated to an object which has not been
assigned to a callback using <code>quick_assign()</code> or <code>assign()</code>. This is aimed at providing an alternative
way to handle messages in a more centralized fashion, but at the moment the API is still very limited.
You can check <a href="https://github.com/Smithay/wayland-rs/issues/287">this Github issue</a> to follow its evolution.</li>
</ul>
<p>If most of your logic resides in callbacks, the main loop of your app can thus be as simple as:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    let ret = event_queue.dispatch(
        &amp;mut global_state,
        |_,_,_| panic!(&quot;An event was received not assigned to any callback!&quot;)
    );
    if let Err(e) = ret {
        // Some error was returned, this means that the Wayland connection is lost
        // most of the time there is nothing more to do than print a nice error message
        // and exit
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you need a more complex handling of the dispatching (in the case of a multithreaded app, or
if you have more than one source of events to handle), the three steps (flushing the outgoing buffer,
reading the socket, and dispatching the events) can be done independently using respectively
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.Display.html#method.flush"><code>Display::flush()</code></a>,
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html#method.prepare_read"><code>EventQueue::prepare_read()</code></a>, and
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html#method.dispatch_pending"><code>EventQueue::dispatch_pending()</code></a>.</p>
<p>Having this in mind, let's see in the next part how to proceed to the initial setup of a Wayland app.</p>
<h1><a class="header" href="#initializing-an-app" id="initializing-an-app">Initializing an app</a></h1>
<p>As described previously, once initialized, <code>wayland-client</code> provides you with
a <a href="https://docs.rs/wayland-client/*/wayland_client/struct.Display.html"><code>Display</code></a> object, representing your wayland connection. This is <em>not</em> a
proxy for the initial <code>WlDisplay</code> protocol object, but it derefs to
<code>&amp;Proxy&lt;WlDisplay&gt;</code>, for convenience.</p>
<p>The first things to do are thus to create an event queue and attach the <code>WlDisplay</code>
proxy to it, so that objects created from it will be attached to this event queue.</p>
<p>The skeleton of a Wayland app may thus look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">use wayland_client::Display;

fn main() {
    let display = Display::connect_to_env().expect(&quot;Failed to find a Wayland socket.&quot;);

    let mut event_queue = display.create_event_queue();
    let attached_display = display.attach(event_queue.token());

    /*
    * Proceed to initialize the rest of your app
    */

    // and the main loop
    loop {
        event_queue.dispatch(&amp;mut global_state, |_,_,_| panic!(&quot;Orphan event&quot;))
            .expect(&quot;Wayland connection lost.&quot;);

        /*
        * Additionnal global processing
        */
    }
}
</code></pre></pre>
<p>With that in place, we can now proceed to the final core concept of the protocol: the globals
and the registry.</p>
<h1><a class="header" href="#the-registry-and-globals" id="the-registry-and-globals">The registry and globals</a></h1>
<p>The Wayland protocol is designed in a modular fashion: all capabilities proposed by
the server to clients are each represented by modules, that are called &quot;globals&quot; in
the Wayland jargon.</p>
<p>A global is a blueprint advertized by the Wayland server to its clients, that the
client can instanciate into a Wayland protocol object, which will expose the
appropriate requests and events for interacting with the capability they represent.
This process of advertizing and instanciating is done with an other special
protocol object: the registry.</p>
<h2><a class="header" href="#the-registry" id="the-registry">The registry</a></h2>
<p>The registry is a protocol object with interface <code>wl_registry</code>. It is created from
an attached <code>wl_display</code> via its
<a href="https://docs.rs/wayland-client/*/wayland_client/protocol/wl_display/struct.WlDisplay.html#method.get_registry"><code>get_registry()</code></a>
method. Upon creation, the server will send it a stream of events telling the client
about which globals are available.</p>
<p>A global advertisement is composed of 3 values:</p>
<ul>
<li>the global name, an <code>u32</code> identifier which represents the global within the globals list
(it is <em>not</em> the same thing as the protocol id of the objects created by instanciating this
global)</li>
<li>the global interface, a string containing the name of the interface of the protocol objects
created from this global</li>
<li>the global version, an <code>u32</code> greater or equal to 1, which is used for protocol versionning</li>
</ul>
<p>The Wayland protocol can evolve, and the interfaces are versionned. The number the server sends
is the highest version it supports. The server must support all lower versions as well.</p>
<p>Upon receiving this list, the client can then instanciate the globals it whishes to use into
protocol objects using the
<a href="https://docs.rs/wayland-client/*/wayland_client/protocol/wl_registry/struct.WlRegistry.html#method.bind"><code>bind</code></a>
method of the registry.</p>
<h2><a class="header" href="#the-two-kinds-of-globals" id="the-two-kinds-of-globals">The two kinds of globals</a></h2>
<p>The various globals that a Wayland server can advertize can be roughtly classified in two kinds,
depending on whether they can be advertized multiple times by the server.</p>
<p><em>Singleton globals</em> represent a capability of the compositor. This is something the Wayland server
makes possible for clients to do. They generally exist from the start, never change and are
advertized only once.</p>
<p><em>Multi globals</em> however represent some device the server has access to. For example a monitor,
or an input device. These globals can thus exist with multiplicity. For example, the
server will advertized one <code>wl_output</code> global for each monitor that is plugged in the computer,
each with a different <code>name</code>. Furthermore, these globals can appear or dissapear during the
lifetime of the app, as such devices are plugged in or out.</p>
<p>The registry <code>Global</code> event signals a new global, while its <code>GlobalRemove</code> event signals that a
given global has been removed. When a such a global is removed, all the protocol objects derived
from it will generally become inert, and the client is then expected to do cleanup by destroying
them using the appropriate requests.</p>
<h2><a class="header" href="#the-globalmanager" id="the-globalmanager">The GlobalManager</a></h2>
<p>Tracking the list of globals, their versions, and instanciating them requires some work that can be
automated away, as such, <code>wayland-client</code> provides an abstraction which simplifies this work for you,
the <a href="https://docs.rs/wayland-client/*/wayland_client/struct.GlobalManager.html"><code>GlobalManager</code></a>.
SCTK further provides other abstractions on top of it, for more convenience, which will be presented
in the following sections. The rest of the client-side half of book will be dedicated to understanding
the different globals and how to use them.</p>
<p>Before jumping to that, lets put all this together with a small app that connects to the wayland server,
receives the list of globals, and prints them to the console:</p>
<pre><pre class="playground"><code class="language-rust">use wayland_client::{Display, GlobalManager};

fn main() {
    // Connect to the server
    let display = Display::connect_to_env().unwrap();

    // Create the event queue
    let mut event_queue = display.create_event_queue();
    // Attach the display
    let attached_display = display.attach(event_queue.token());

    // We use the GlobalManager convenience provided by the crate, it covers
    // most classic use cases and avoids us the trouble to manually implement
    // the registry
    let globals = GlobalManager::new(&amp;attached_display);

    // sync_roundtrip is a special kind of dispatching for the event queue.
    // Rather than just blocking once waiting for replies, it'll block
    // in a loop until the server has signalled that it has processed and
    // replied accordingly to all requests previously sent by the client.
    //
    // In our case, this allows us to be sure that after this call returns,
    // we have received the full list of globals.
    event_queue.sync_roundtrip(
        // we don't use a global state for this example
        &amp;mut (),
        // The only object that can receive events is the WlRegistry, and the
        // GlobalManager already takes care of assigning it to a callback, so
        // we cannot receive orphan events at this point
        |_, _, _| unreachable!()
    ).unwrap();

    // GlobalManager::list() provides a list of all globals advertized by the
    // server
    println!(&quot;Available globals:&quot;);
    for (name, interface, version) in globals.list() {
        println!(&quot;{}: {} (version {})&quot;, name, interface, version);
    }
}
</code></pre></pre>
<h1><a class="header" href="#getting-started-with-sctk" id="getting-started-with-sctk">Getting started with SCTK</a></h1>
<p>In the previous section we explored the general structure of the Wayland protocol,
as well as how a Wayland app is initialized using the display and the registry to
get the list of globals.</p>
<p>We will now introduce <a href="https://docs.rs/smithay-client-toolkit">SCTK</a> (short for
<em>Smithay Client Toolkit</em>), a toolkit crate that provides various abstractions to
simplify large parts of the plumbing required to make a Wayland app. This section
will cover the steps to setup an app using SCTK, create a window and draw to it.</p>
<h1><a class="header" href="#the-environment" id="the-environment">The Environment</a></h1>
<p>SCTK provides a system that handles the listing and instanciation of globals
needed by your app: the <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/environment/struct.Environment.html"><code>Environment</code></a>. This system is highly modular, but
SCTK also provides a preset for it, that will automatically instanciate all
the globals needed for a regular app. This preset comes in the form of two macros:
<a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/macro.default_environment.html"><code>default_environment!</code></a>
and <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/macro.new_default_environment.html"><code>new_default_environment!</code></a>.</p>
<p>The first one is used to declare the environment struct for your app. We will use the <code>desktop</code> preset,
and we need to also provide a name, this example will use <code>MyApp</code>, but you can use anything. The second
macro needs to be called for initializing the environment, and we need to give it the <code>desktop</code> preset
as well.</p>
<p>The <code>new_default_environment!</code> takes care of connecting to the Wayland socket, creating an event queue,
and initializing the environment on it. On success it returns a tuple of 3 values:</p>
<ul>
<li>The environment, of type <code>Environment&lt;MyApp&gt;</code></li>
<li>The <code>Display</code></li>
<li>The <code>EventQueue</code> the environment is associated with</li>
</ul>
<p>The environment will then provide several methods mapping the functionality of the various underlying
globals. SCTK generally provides an higher-level interface to the underlying functionality than what
the Wayland protocol directly encodes via its globals.</p>
<p>The previous example of listing all globals can be reframed as such using the environment system:</p>
<pre><pre class="playground"><code class="language-rust no_run">use smithay_client_toolkit::{default_environment, new_default_environment};

default_environment!(MyApp, desktop);

fn main() {
    let (environment, display, event_queue) = new_default_environment!(MyApp, desktop)
        .expect(&quot;Failed to initialize the Wayland environment.&quot;);

    // environment.manager is the underlying GlobalManager
    println!(&quot;Available globals:&quot;);
    for (name, interface, version) in environment.manager.list() {
        println!(&quot;{}: {} (version {})&quot;, name, interface, version);
    }
}
</code></pre></pre>
<h1><a class="header" href="#creating-a-window" id="creating-a-window">Creating a Window</a></h1>
<p>In order to display content on Wayland, it is necessary to first understand a central
concept of the Wayland protocol: the surfaces.</p>
<h2><a class="header" href="#surfaces" id="surfaces">Surfaces</a></h2>
<p>One of the core globals of the Wayland protocol is the <a href="https://docs.rs/wayland-client/*/wayland_client/protocol/wl_compositor/index.html"><code>wl_compositor</code></a>. It allows the creation
of surfaces (object with the interface <a href="https://docs.rs/wayland-client/*/wayland_client/protocol/wl_surface/index.html"><code>wl_surface</code></a>), which are the main building block for
displaying content to the screen.</p>
<p>You can think of a surface as a canvas. In order to display content to the screen, it is needed
to draw the content on the surface (see <a href="client/sctk/./drawing.html">next page</a>), and to assign a <em>role</em> to it.</p>
<p>Roles are how Wayland apps tell the server what a surface is meant to be. The most central role is
the role of a &quot;shell surface&quot;: this surface is meant to be a window the user can interact with.
However other roles are possible, such as assigning a surface to replace the pointer icon.</p>
<p>SCTK's environment provides a quick method for creating new surfaces: <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/environment/struct.Environment.html#method.create_surface"><code>Environment::create_surface()</code></a>.</p>
<h2><a class="header" href="#sctks-window" id="sctks-window">SCTK's Window</a></h2>
<p>The Wayland protocol defines an other global, <code>xdg_shell</code> which is used to create the appropriate objects
for assigning the &quot;shell surface&quot; role to a surface. For this current quickstart however, we don't need
to dig into its complexity, instead we can use the <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/window/struct.Window.html"><code>Window</code></a> adapter provided by SCTK, which handles most
of the plumbing for us.</p>
<p>We can create a <code>Window</code> by using the <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/environment/struct.Environment.html#method.create_window"><code>Environment::create_window()</code></a> method. It requires us to provide
a <code>WlSurface</code> which will be the base of this window, initial dimensions for the window, and a callback
to process events generated by the user manipulation the Window. The <code>Window</code> provided by SCTK will take
care of declaring the surface as being a shell surface, and of drawing some simple decorations for the
window if the environment does not provide them. The drawing of these decorations is also a modular element,
and we will use there the implementation provided by SCTK, that we pass as a type parameter.</p>
<pre><pre class="playground"><code class="language-rust no_run">use smithay_client_toolkit::{
    default_environment, new_default_environment,
    window::ConceptFrame
};

default_environment!(MyApp, desktop);

fn main() {
    let (environment, display, event_queue) = new_default_environment!(MyApp, desktop)
        .expect(&quot;Failed to initialize the Wayland environment.&quot;);

    let surface = environment.create_surface().detach();

    let window = environment
        .create_window::&lt;ConceptFrame, _&gt;(
            surface,    // the surface this window is based on
            None,       // theme manager
            (800, 600), // the initial dimensions
            |event, dispatch_data| { /* A closure to handle the window-related events */ },
        )
        .expect(&quot;Unable to setup the window.&quot;);
}
</code></pre></pre>
<h2><a class="header" href="#window-events" id="window-events">Window events</a></h2>
<p>The <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/window/enum.Event.html"><code>Event</code></a> generated by the <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/window/struct.Window.html"><code>Window</code></a> are of three kind:</p>
<p>The first is <code>Event::Close</code>. It is sent to you when the user has requested that the window be closed
(for example by clicking the relevant button on the decorations). Depending on the desktop environment,
the window may or may not have been hidden by the Wayland server, so you cannot rely on it, you need to
hide your window, either by dropping the <code>Window</code> (and maybe exiting your program if that's what is intended),
or by submitting empty content to the surface (see <a href="client/sctk/./drawing.html">next page</a>).</p>
<p>The second kind is <code>Event::Refresh</code>. This event is used by the window to tell you it needs to redraw
the decorations. This is not done automatically because it is a costly operation. You will generally
want to manually trigger it by calling <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/window/struct.Window.html#method.refresh"><code>Window::refresh</code></a> just before redrawing the contents of your
window.</p>
<p>The last kind is <code>Event::Configure</code>. This event tells you that something about the state of the
window has changed. If the <code>new_size</code> field is <code>Some()</code>, this means that the Wayland server is
suggesting a new size to your window, most likely the result of a resizing action from the user.
The <code>state</code> fields provides a list of state about your window (is it maximized, or in the process
of being resized ?), that you may need to properly draw your contents (see <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/window/enum.State.html"><code>State</code></a> for the details).
This event implies that the decorations need to be redrawn.</p>
<p>Note that when your window is in the process of being resized by the user, the Wayland server will
send <em>a lot</em> of <code>Configure</code> events with new sizes. Attempting to redraw your content in response to
every one of them will render your app extremely laggy. Your app actually only needs to process the last
one of the batch to behave correctly, as such it is good practice to buffer their content into some
global state (using the <code>DispatchData</code> for example) and process this accumulated data once the dispatching
process of the event queue is finished.</p>
<p>Furthermore, unless your app is fullscreen, the size suggested by the Wayland server is a non-binding
suggestion, you are free to ignore it, or to adjust it (if your app should only resize itself in increments
for example).</p>
<p>The structure of an app processing its window events into a global state would look like that:</p>
<pre><pre class="playground"><code class="language-rust no_run">use smithay_client_toolkit::{
    default_environment, new_default_environment,
    window::{ConceptFrame, Event as WindowEvent},
};

default_environment!(MyApp, desktop);

struct MyState {
    new_size: Option&lt;(u32, u32)&gt;,
    close_requested: bool,
    refresh_requested: bool,
    /* The rest of the state of your app */
}

fn main() {
    let (environment, _display, mut event_queue) =
        new_default_environment!(MyApp, desktop)
        .expect(&quot;Failed to initialize the Wayland environment.&quot;);

    let surface = environment.create_surface().detach();

    let mut window = environment.create_window::&lt;ConceptFrame, _&gt;(
        surface,    // the surface this window is based on
        None,       // theme manager
        (800, 600), // the initial dimensions
        |event, mut dispatch_data| {
            // We acess the global state through `DispatchData`
            let state = dispatch_data.get::&lt;MyState&gt;().unwrap();
            match event {
                // Store the request to close the window or refresh the frame to process
                // it later in the main loop
                WindowEvent::Close =&gt; state.close_requested = true,
                WindowEvent::Refresh =&gt; state.refresh_requested = true,
                // If the configure event contains a new size, overwrite the currently
                // stored new_size with it
                WindowEvent::Configure { new_size, .. } =&gt; if new_size.is_some() {
                    state.new_size = new_size
                }
            };
        }
    ).expect(&quot;Unable to setup the window.&quot;);

    // Initialize the global state, for use in the main loop
    let mut global_state = MyState {
        new_size: None,
        close_requested: false,
        refresh_requested: false,
        /* The rest of the state of your app */
    };

    // The mail event loop of the program
    loop {
        // Provide the global state to dispatch(), so that the Window
        // callback can access it
        event_queue.dispatch(
            &amp;mut global_state,
            |_,_,_| panic!(&quot;An event was received not assigned to any callback!&quot;)
        ).expect(&quot;Wayland connection lost!&quot;);

        if global_state.close_requested {
            // The user requested to close the app, exit the loop
            break;
        }
        // If we changed size, we need to tell it to the Window, so that it draws
        // decorations with the correct size. And we thus need to tell it *before*
        // calling the refresh() method.
        if let Some((w, h)) = global_state.new_size {
            window.resize(w, h);
        }
        if global_state.refresh_requested || global_state.new_size.is_some() {
            // refresh the decorations if needed &amp; reset the refresh flag
            window.refresh();
            global_state.refresh_requested = false;
        }

        /*
         * We can now redraw our contents if needed: is we have a new size,
         * or if the run of our app requires us to redraw. See next page about
         * how to draw to a surface.
         */
    }
}
</code></pre></pre>
<p>Let's continue to the next page to see how we can actually draw content to this Window.</p>
<h1><a class="header" href="#drawing-to-a-window" id="drawing-to-a-window">Drawing to a Window</a></h1>
<p>Drawing to a surface is done by attaching buffers to it, though the <a href="https://docs.rs/wayland-client/*/wayland_client/protocol/wl_surface/struct.WlSurface.html#method.attach"><code>WlSurface::attach()</code></a> method.
This method takes as argument an optional <a href="https://docs.rs/wayland-client/*/wayland_client/protocol/wl_buffer/index.html"><code>WlBuffer</code></a>, and coordinates of this buffer relative to the
current content. This last bit allows to control in which direction the rectangle of the surface should
grow or shrink, but is pretty anecdotical. Most of the tme you will just set these to <code>(0, 0)</code>.</p>
<p>The <code>Option&lt;&amp;WlBuffer&gt;</code> is the main part of drawing. A buffer defines the totality of the contents of
a surface, including its size. It is mostly a reference to an array of pixels that the Wayland server
will use to fill the surface contents. Updating the contents of a surface amounts to attaching a new
buffer to it, replacing the previous one. Attaching <code>None</code> to a surface erases its content, causing the
surface to be hidden by the server.</p>
<p>The act of drawing is this creating a <a href="https://docs.rs/wayland-client/*/wayland_client/protocol/wl_buffer/index.html"><code>WlBuffer</code></a> refering to an array of pixels with the appropriate
content. There are two main approaches for producing such a buffer: drawing to shared memory, or via
OpenGL/Vulkan. We will now focus on the first method, leaving OpenGL and Vulkan for later.</p>
<h2><a class="header" href="#shared-memory" id="shared-memory">Shared Memory</a></h2>
<p>The principle of shared memory for drawing content is that the client first creates a memory-backed file
(for example using <a href="https://man7.org/linux/man-pages/man2/memfd_create.2.html"><code>memfd_create</code></a>), and shares its file descriptor with the server. The client can
then draw its content by writing to the file, and creates buffer pointing to the appropriate part of the
file, similarly to a rust slice pointing to part of a <code>Vec</code>. The client can thus write the content of
several different buffers to the same file, avoiding the need to open many file descriptors (file descriptor
leaks are a real thing!).</p>
<p>When a buffer has been attached to a surface and submitted to the compositor, its associated pixel array
should no longer be changed until it has finished reading it, or graphical glitches may occur. As a result,
clients are encouraged to do double-buffering: maintaining two shared memory files, and drawing to one while
the other is in use by the server.</p>
<p>As one can expect, the capability to create buffers backend by shared memory is represented, by a global:
<a href="https://docs.rs/wayland-client/*/wayland_client/protocol/wl_shm/index.html"><code>wl_shm</code></a>. However as previously, SCTK provides an abstraction to make handling such shared memory easier:
the <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/shm/struct.DoubleMemPool.html"><code>DoubleMemPool</code></a>. As its name can let you guess, it also manages double-buffering.</p>
<p>We can create a <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/shm/struct.DoubleMemPool.html"><code>DoubleMemPool</code></a> from the environment using the <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/environment/struct.Environment.html#method.create_double_pool"><code>Environment::create_double_pool()</code></a> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut double_pool = environment.create_double_pool(|_| {})
    .expect(&quot;Failed to create a memory-backed file.&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/shm/struct.DoubleMemPool.html"><code>DoubleMemPool</code></a> keeps track automatically of which of its underlying memory pool is still being used by the
server, allowing us to use the other. If at some point we try to draw and both are still in use, <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/shm/struct.DoubleMemPool.html"><code>DoubleMemPool</code></a>
will not let us access any pool. If that happens, the callback we gave to <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/environment/struct.Environment.html#method.create_double_pool"><code>Environment::create_double_pool()</code></a> will
be invoked as soon as one pool is free again and we can draw. We will not be doing such reactive drawing in this
example, so we just pass an empty callback.</p>
<h2><a class="header" href="#drawing-on-the-memory-pool" id="drawing-on-the-memory-pool">Drawing on the memory pool</a></h2>
<p>When we want to draw, we can start by invoking <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/shm/struct.DoubleMemPool.html"><code>DoubleMemPool::pool()</code></a>, which gives us access to a free
<a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/shm/struct.MemPool.html"><code>MemPool</code></a> or <code>None</code> if both are currently in use. Once we have it, we can write to it like any file, it
implements the <a href="https://doc.rust-lang.org/stable/std/io/trait.Write.html"><code>std::io::Write</code></a> and <a href="https://doc.rust-lang.org/stable/std/io/trait.Seek.html"><code>std::io::Seek</code></a> traits.</p>
<p>For this example, let's just fill the window with red. We will be writing the pixel contents in ARGB8888 format.
This means that each pixel will be represented by 4 bytes: Alpha, Red, Green and Blue values. Our fully opaque
red is thus <code>#FFD00000</code>, or <code>&amp;[0xFF, 0xD0, 0, 0]</code>.</p>
<p>To draw this content, we shall first ensure that the <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/shm/struct.MemPool.html"><code>MemPool</code></a> is large enough to store those contents,
then seek back to the beginning of the file, and write enough of these pixels to fill the whole surface.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{Write, Seek, SeekFrom, BufWriter};
// Only try to draw if there is a free pool
if let Some(pool) = double_pool.pool() {
    // number of pixels in the surface
    let pxcount = width * height;
    // number of bytes corresponding to these pixels
    let bytecount = 4*pxcount;

    // Resize the pool accordingly. It is important to use this method
    // rather than just let the memory file grow by writing to it, because
    // it tells the server about the new size of the file. Note that a
    // memory pool can never shrink, so if the size we request is smaller than
    // its current size, this call will do nothing.
    pool.resize(bytecount).unwrap();

    // Now, seek to the beggining of the memory file, to overwrite its contents
    pool.seek(SeekFrom::Start(0)).unwrap();

    // Finally do the actual drawing. We use a BufWriter to increase performance
    {
        let mut writer = BufWriter::new(&amp;mut *pool);
        for _ in 0..pxcount {
            writer.write_all(&amp;[0xFF, 0xD0, 0x00, 0x00]).unwrap();
        }
        writer.flush().unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#creating-and-attaching-the-buffer" id="creating-and-attaching-the-buffer">Creating and attaching the buffer</a></h2>
<p>Once the <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/shm/struct.MemPool.html"><code>MemPool</code></a> contains the correct pixels, we can create a buffer from it using the <a href="https://docs.rs/smithay-client-toolkit/*/smithay_client_toolkit/shm/struct.MemPool.html#method.buffer"><code>MemPool::buffer()</code></a> method.
This method requires several arguments to correctly define the buffer relative to the memory pool:</p>
<ul>
<li><code>offset</code>: how many bytes from the start of the pool does the buffer start</li>
<li><code>width</code>: the width of the buffer in pixels</li>
<li><code>height</code>: the height of the buffer in pixels</li>
<li><code>stride</code>: the number of bytes between the start of each line</li>
<li><code>format</code>: the pixel format used for interpreting the bytes (in our case <code>Format::Argb8888</code>)</li>
</ul>
<p>The pixel stream from the memory pool is thus interpreted by the server as one line after another, from left to right
and from top to bottom. In our case, the <code>offset</code> is 0, as we wrote our content at the start of the pool. The width
and height are the dimensions of the content we've drawn. Here <code>stride</code> is just <code>width * 4</code>, as there are 4 bytes per pixel.</p>
<p>We can thus create our buffer using:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use smithay_client_toolkit::shm::Format;

let buffer = pool.buffer(0, width, height, 4 * height, Format::Argb8888);
<span class="boring">}
</span></code></pre></pre>
<p>And finally, the last remaining thing to do is to attach this buffer to the surface, declare the damage, and commit the surface.
Declaring the damage tells the server which part of the content actually changed since the last submitted buffer. This allows
it to optimize its drawing process to only update parts of the screen that need updating. For this example, we will simply
declare the whole buffer as damaged.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>surface.attach(Some(&amp;buffer), 0, 0);
surface.damage_buffer(0, 0, width, height);
surface.commit();
<span class="boring">}
</span></code></pre></pre>
<p>The <code>commit()</code> call is necessary because the state of the surface is double-buffered. We are changing two properties of the
surface here: its attached buffer, and the parts that are damaged. Once we've sent these requests the server will keep these
new properties on hold, and apply them atomically when we send the <code>commit</code> request.</p>
<p>With this, you are now able to display content on a Wayland window, congratulations! To wrap all this together, the next
page will be an exercice to code a simple image viewer app: it'll display an image and stretch its content when resized.</p>
<h1><a class="header" href="#exercice-an-image-viewer" id="exercice-an-image-viewer">Exercice: an image viewer</a></h1>
<p>This exercise aims at allowing you to put together all the things we have seen in this introduction
to SCTK. The goal is to write an app that loads an image from disk and displays it as the only
content of its window. It should react to resizing by stretching the image so that it fills the
size given to the window.</p>
<h2><a class="header" href="#using-the-image-crate" id="using-the-image-crate">Using the <code>image</code> crate</a></h2>
<p>Manipulating images is not the main goal of this exercise, so you can just use the <code>image</code> crate to
do it for you. In particular:</p>
<ul>
<li><a href="https://docs.rs/image/0.23.8/image/fn.open.html"><code>image::open</code></a> can load an image file from disk</li>
<li><a href="https://docs.rs/image/0.23.8/image/imageops/fn.resize.html"><code>image::imageops::resize</code></a> can be used
to resize the image accordingly</li>
</ul>
<h2><a class="header" href="#general-advice" id="general-advice">General advice</a></h2>
<p>To organize your program, you'll probably find it useful to split the actual drawing code into its
own function, taking as argument the <code>&amp;mut MemPool</code> to use, the <code>&amp;WlSurface</code> to which commit the buffer,
the requested dimensions, and the image.</p>
<p>The <code>xdg_shell</code> global, used by <code>Window</code>, requires you to wait until you have received at least one
<code>Configure</code> event before drawing your content. Commiting a buffer before you've received it will be
considered as a protocol error by the server, which will cause it to kill your connection.</p>
<p>Be careful about the pixel format, <code>image</code> provides you with the pixels in RGBA format, but the Wayland
server will expect them as ARGB.</p>
<h2><a class="header" href="#solution" id="solution">Solution</a></h2>
<p>A solution to this exercice with detailed comments can be found as the
<a href="https://github.com/Smithay/client-toolkit/blob/master/examples/image_viewer.rs"><code>image_viewer.rs</code> example of SCTK</a>.</p>
<h1><a class="header" href="#wayland-compositors" id="wayland-compositors">Wayland Compositors</a></h1>
<p>Work in Progress.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
