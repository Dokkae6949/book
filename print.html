<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Smithay Handbook</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="client/intro.html"><strong aria-hidden="true">1.</strong> Wayland apps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/general/intro.html"><strong aria-hidden="true">1.1.</strong> General principles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/general/objects.html"><strong aria-hidden="true">1.1.1.</strong> Objects</a></li><li class="chapter-item expanded "><a href="client/general/event_queues.html"><strong aria-hidden="true">1.1.2.</strong> Event queues and filters</a></li><li class="chapter-item expanded "><a href="client/general/initializing.html"><strong aria-hidden="true">1.1.3.</strong> Initializing an app</a></li><li class="chapter-item expanded "><a href="client/general/registry.html"><strong aria-hidden="true">1.1.4.</strong> The registry and globals</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">1.2.</strong> Getting started with SCTK</li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">1.2.1.</strong> The Environment</li><li class="chapter-item expanded "><strong aria-hidden="true">1.2.2.</strong> Creating a Window</li><li class="chapter-item expanded "><strong aria-hidden="true">1.2.3.</strong> Drawing to a Window</li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.</strong> Processing user input</li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">1.3.1.</strong> The seats</li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.2.</strong> Pointers</li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.3.</strong> Keyboards</li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.4.</strong> Touchscreens</li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">1.4.</strong> Multiple outputs and HiDPI</li><li class="chapter-item expanded "><strong aria-hidden="true">1.5.</strong> Cliboard and Drag'n'Drop</li></ol></li><li class="chapter-item expanded "><a href="server/intro.html"><strong aria-hidden="true">2.</strong> Wayland Compositors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Smithay Handbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the Smithay Handbook.</p>
<p>This is a work in progress, and intended to serve as a general manual for building Wayland-related
software in Rust, using the tools from the <a href="https://smithay.github.io/">Smithay project</a>.</p>
<p>The project revolves around 3 main components:</p>
<ul>
<li>The <a href="https://github.com/Smithay/wayland-rs">wayland-rs</a> repository contains low-level bindings to the
Wayland protocols, under the form of several crates. The two most notable being
<a href="https://crates.io/crates/wayland-client"><code>wayland-client</code></a> and
<a href="https://crates.io/crates/wayland-server"><code>wayland-server</code></a>, which are the core bindings for client-side
and server-side apps.</li>
<li><a href="https://crates.io/crates/smithay-client-toolkit">SCTK</a>, or Smithay Client ToolKit, is a crate designed
to handle a significant portion of the plumbing required for writing Wayland client apps. It comes on top
of wayland-client, and this book will present it as well.</li>
<li><a href="https://github.com/Smithay/smithay">Smithay</a> is the flagship crate of the project, and is designed as
a framework for writing Wayland servers (also called compositors). It is built on top of the wayland-server
crate, and also handles most of the interaction with the system (input devices, graphics, udev, sessions, ...).</li>
</ul>
<p>The first part of this book is dedicated to client-side apps, while the second part focuses of server-side.
If you are interested by the server-side stuff, it is recommended to first get familiar with the client-side,
as it is easier to get into and a lot of its concepts map to server-side.</p>
<h1><a class="header" href="#wayland-apps" id="wayland-apps">Wayland apps</a></h1>
<p>This part of the book is dedicated to Wayland client apps, so writing programs that can run in
a Wayland environment: display something to the screen, receive user input and process it. This
include classic apps wich display a window with their content, but can also include programs such
as desktop components (widgets, bars, animated backgrounds, lockscreens, ...).</p>
<p>The first section will be dedicated to general principles of the wayland protocol, as well as the
main objects of the <a href="https://crates.io/crates/wayland-client">wayland-client</a> crate. The following
sections will explore in more details the actual process of writing an app.</p>
<h1><a class="header" href="#general-principles" id="general-principles">General principles</a></h1>
<p>The Wayland protocol follows a client-server architecture: the Wayland compositor listens
on an UNIX socket, to which client apps then connect in order to present their graphical
interface. This UNIX connection transports information in both directions: the client uses
it to tell the server what it wants to display, and the server uses it to tell the client
about user actions (such as keyboard or pointer input). The Wayland connection is thus the
heart of a client app, and is the source of events that drives its event loop.</p>
<p>The server tells to clients about the Wayland socket using the <code>WAYLAND_DISPLAY</code> environment
variable. The listening socket is placed at <code>$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY</code>. This will
typically be a path like <code>/run/user/1000/wayland-0</code>.</p>
<p>When starting your app, it will need to find the Wayland socket and connect to it. The
wayland-client crate does this for you with the
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.Display.html#method.connect_to_env"><code>Display::connect_to_env()</code></a>
method. If no error occurs, this function will provide you with a <code>Display</code> object.</p>
<p>This object is the very heart of your Wayland program. It represents your connection to the
server, and this is from this object that everything will be further initialized. But to
understand how this objects relates to the rest of the crate, we will first need to get a
better understanding of the distinction between the protocol objects, and the Rust structs that
your program will manipulate.</p>
<h1><a class="header" href="#objects" id="objects">Objects</a></h1>
<p>The Wayland protocol is an object-oriented protocol. This means that, as the client and
server exchange messages, they build an abstract state made of several objects, which
are represented by a numeric identifier. You can figure them as being scopes for messages:
each message is associated with one of these protocol object. Each object has an &quot;interface&quot;,
which is a definition of which messages can be associated with it.</p>
<p>The messages are named &quot;requests&quot; when they are sent by the client to the server, and &quot;events&quot;
when they are sent by the server to the client. An object interface is thus the list of which
requests and which events can be associated with objects of this interface.</p>
<p>For example, an object representing a keyboard would receive the events from the server informing
about which keys are pressed by the user. An object representing a window would send requests
to update its content, and receive events informing about user interaction (such as resizing).</p>
<p>At the beginning, the protocol state contains a single object. Its identifier is 1, and its
interface is <code>wl_display</code>. This is from it that the rest of the protocol state is setup by
the client.</p>
<h2><a class="header" href="#objects-and-proxies" id="objects-and-proxies">Objects and proxies</a></h2>
<p>The protocol objects are created and destroyed by messages. A request sent by the client can
have for effect the creation of a new object in the state, or the destruction of an object.
Most of the time, creation and destruction of objects is done by the client, but there are
exceptions. For this reason, protocol objects are not directly represented by Rust structs,
but instead one layer of indirection is added. <code>wayland-client</code> provides you with Rust objects
that we call &quot;proxies&quot;.</p>
<p>Each proxy represents a protocol object, but several proxies can represent the same object. You
can think of proxies as something akin <code>Rc&lt;_&gt;</code> or <code>Arc&lt;_&gt;</code>: they are an handle to the underlying
protocol object. Furthermore, their lifetime is not tied to the protocol object's lifetime: they
can outlive it. Once a protocol object has been destroyed, the proxies associated to it will
become inert.</p>
<h2><a class="header" href="#the-4-forms-of-a-proxy" id="the-4-forms-of-a-proxy">The 4 forms of a proxy</a></h2>
<p>A proxy for a protocol object can be manipulated under four forms:</p>
<ul>
<li>As direct proxy, as a bare Wayland type, something like <code>WlFoo</code>. This form is the
closest to the protocol object, and its methods map to the requests of the interface of
this object.</li>
<li>As a <code>Proxy&lt;WlFoo&gt;</code>. In this form, you can manipulate the proxy as a proxy, rather than
as a protocol object. This lets you do things like check if the underlying object is still
alive, retrieve its ID, or access the user data associated with it (see below).</li>
<li>As an <code>Attached&lt;WlFoo&gt;</code>. This form is very similar to the bare <code>WlFoo</code>, but it additionnaly
allows you to send requests that create new objects (doing so with a bare <code>WlFoo</code> will panic).</li>
<li>As a <code>Main&lt;WlFoo&gt;</code>. This form is similar to <code>Attached&lt;WlFoo&gt;</code>, but additionnaly allows you to
change the event handler associated with the Wayland object.</li>
</ul>
<p>We will soon explain the role of event handlers and <code>Main&lt;_&gt;</code> and <code>Attached&lt;_&gt;</code> proxies in the
context of event queues, but before that, a quick word about user data.</p>
<h2><a class="header" href="#user-data" id="user-data">User data</a></h2>
<p><code>wayland-client</code> makes it possible to associate some data with a protocol object, via the
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.Proxy.html#method.user_data"><code>Proxy&lt;_&gt;::user_data()</code></a>
method. This method gives you access to a <code>&amp;UserData</code> value, which holds the associated data.
The important part is that <em>all proxies associated to the same protocol object give you access
to the same <code>&amp;UserData</code></em>. The value you associate with it is thus attached to the protocol
object, rather than the proxy. This mechanism is largely used accross wayland apps, as it is
not rare to have several proxies for the same object.</p>
<p>The <a href="https://docs.rs/wayland-client/*/wayland_client/struct.UserData.html"><code>UserData</code></a> type is a
set-once style container: you can only set its value once, and then you can get a <code>&amp;</code>-reference
to its contents provided you know the type of the stored value. If you need the associated data
to be mutable, you need to handle interior-mutability (by storing a <code>RefCell</code> or a <code>Mutex</code> for
example).</p>
<p>Lets now discuss event queues.</p>
<h1><a class="header" href="#event-queues-and-filters" id="event-queues-and-filters">Event queues and filters</a></h1>
<p>If the <a href="https://docs.rs/wayland-client/*/wayland_client/struct.Display.html"><code>Display</code></a> is the heart of your Wayland app, the <a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a> will be its
backbone. As described in the previous section, messages are sent in both directions,
and so far we only discussed how to send requests (using the methods of bare proxies),
but not how to receive events. This is done via event queues and callbacks.</p>
<h2><a class="header" href="#event-callbacks" id="event-callbacks">Event callbacks</a></h2>
<p>Each protocol object can be assigned to a callback, which will be invoked whenever
this object receives an event. The event callback receives 3 arguments:</p>
<ul>
<li>a <code>Main&lt;_&gt;</code> proxy to the object this event is associated to</li>
<li>a the event itself, under the form of the <code>Event</code> enum of the interface of this object</li>
<li>a mutable reference to the <code>DispatchData</code>, which is some global mutable state shared
by the event queue (we will get into details about that when explaining the event queue)</li>
</ul>
<p>This callback should then contain the logic of your program for handling this event. This
may require anything from just storing the new information somewhere to process it later,
to directly responding to the server by sending a request, from within the callback.</p>
<p>The direct way to assign a callback to an object is via the 
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.Main.html#method.quick_assign"><code>Main&lt;_&gt;::quick_assign()</code></a>
method, which requires to be given a callback under the form of an <code>FnMut</code> closure. You can
thus capture values in the callback, but it must be a <code>'static</code> closure, so it cannot
capture references, only values (this implies it must be a <code>move</code> closure if it captures
anything).</p>
<p>An alternative approach is to use a <a href="https://docs.rs/wayland-client/*/wayland_client/struct.Filter.html"><code>Filter</code></a>. You can think of filters as a <code>Rc&lt;_&gt;</code> wrapper
around a closure. Filters allow you to use the same closure to process events from several
objects, making state sharing easier. They are a more advanced use, and we shall come back to
them later.</p>
<h2><a class="header" href="#event-queues-and-attached-proxies" id="event-queues-and-attached-proxies">Event queues and Attached proxies</a></h2>
<p><a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a>s are the type which actually read events from the Wayland socket, and
invoke your appropriate callbacks. All protocol objects are associated at creation to an
event queue so that their events are processed.</p>
<p>This is where the <code>Attached&lt;_&gt;</code> proxies come into play. Given a <code>Proxy&lt;_&gt;</code>, you can attach
it to an <a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a> like so, using a event queue token:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let attached_proxy = proxy.attach(&amp;event_queue.token());
<span class="boring">}
</span></code></pre></pre>
<p>Attaching a proxy only affects the proxy, not the protocol object. The effect is that whenever
a request is sent that creates a new object, this newly created object will be associated to
the event queue to which its creator proxy is attached. Given an object must always be associated
with an event queue, requests creating new object are thus only allowed from <code>Attached&lt;_&gt;</code>
proxies. <code>Main&lt;_&gt;</code> proxies behave like <code>Attached&lt;_&gt;</code> ones, being attached to the same queue
as the one the underlying object is associated to. Creating new objects directly from the
same event queue as their parent object is by far the most frequent case.</p>
<p><a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a>s are cannot be shared between threads (they are <code>!Send</code> and <code>!Sync</code>),
this mechanism thus allow to associate different objects to different queues, and
potentially different threads, and is required for handling that in a threadsafe way.
Following that, <code>Attached&lt;WlFoo&gt;</code> and <code>Main&lt;WlFoo&gt;</code> are not <code>Send</code> either, while
<code>WlFoo</code> and <code>Proxy&lt;WlFoo&gt;</code> are.</p>
<h2><a class="header" href="#dispatching-event-queues" id="dispatching-event-queues">Dispatching event queues</a></h2>
<p>To receive events, it is necessary to read the Wayland socket and call the appropriate callbacks.
We call this process &quot;dispatching&quot;, and as <code>wayland-client</code> does not take the control-flow away
from you, you need to tell it to do it.</p>
<p>The simplest way to achieve that is with the
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html#method.dispatch"><code>EventQueue::dispatch()</code></a>
method. This method does 3 things:</p>
<ul>
<li>Flush the outgoing buffer (when sending a request, it is not directly written to the socket but instead
buffered, to improve performance)</li>
<li>Read pending events from the socket, if none are available block until some are received, and distribute
these events to the internal buffer of their target event queue</li>
<li>Empty the internal buffer of the event queue on which the method was called by invoking the appropriate
callbacks</li>
</ul>
<p>This method also requires you to provide two additional arguments:</p>
<ul>
<li>A mutable reference to some value <code>&amp;mut T</code>: this reference is accessible from all callbacks invoked by this
event queue as the <code>&amp;mut DispatchData</code> argument. If they wish to use it, the callbacks need to handle the
downcasting using the methods provided by <a href="https://docs.rs/wayland-client/*/wayland_client/struct.DispatchData.html"><code>DispatchData</code></a>, in a similar fashion as <code>Any</code>. This value is
typically used to serve as the global state of your app.</li>
<li>A fallback closure. This closure will be invoked for all events associated to an object which has not been
assigned to a callback using <code>quick_assign()</code> or <code>assign()</code>. This is aimed at providing an alternative
way to handle messages in a more centralized fashion, but at the moment the API is still very limited.
You can check <a href="https://github.com/Smithay/wayland-rs/issues/287">this Github issue</a> to follow its evolution.</li>
</ul>
<p>If most of your logic resides in callbacks, the main loop of your app can thus be as simple as:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    let ret = event_queue.dispatch(
        &amp;mut global_state,
        |_,_,_| panic!(&quot;An event was received not assigned to any callback!&quot;)
    );
    if let Err(e) = ret {
        // Some error was returned, this means that the Wayland connection is lost
        // most of the time there is nothing more to do than print a nice error message
        // and exit
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If you need a more complex handling of the dispatching (in the case of a multithreaded app, or
if you have more than one source of events to handle), the three steps (flushing the outgoing buffer,
reading the socket, and dispatching the events) can be done independently using respectively
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.Display.html#method.flush"><code>Display::flush()</code></a>,
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html#method.prepare_read"><code>EventQueue::prepare_read()</code></a>, and
<a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html#method.dispatch_pending"><code>EventQueue::dispatch_pending()</code></a>.</p>
<p>Having this in mind, let's see in the next part how to proceed to the initial setup of a Wayland app.</p>
<h1><a class="header" href="#initializing-an-app" id="initializing-an-app">Initializing an app</a></h1>
<p>As described previously, once initialized, <code>wayland-client</code> provides you with
a <a href="https://docs.rs/wayland-client/*/wayland_client/struct.Display.html"><code>Display</code></a> object, representing your wayland connection. This is <em>not</em> a
proxy for the initial <code>WlDisplay</code> protocol object, but it derefs to
<code>&amp;Proxy&lt;WlDisplay&gt;</code>, for convenience.</p>
<p>The first things to do are thus to create an event queue and attach the <code>WlDisplay</code>
proxy to it, so that objects created from it will be attached to this event queue.</p>
<p>The skeleton of a Wayland app may thus look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">use wayland_client::Display;

fn main() {
    let display = Display::connect_to_env().expect(&quot;Failed to find a Wayland socket.&quot;);

    let mut event_queue = display.create_event_queue();
    let attached_display = display.attach(&amp;event_queue.token());

    /*
    * Proceed to initialize the rest of your app
    */

    // and the main loop
    loop {
        event_queue.dispatch(&amp;mut global_state, |_,_,_| panic!(&quot;Orphan event&quot;))
            .expect(&quot;Wayland connection lost.&quot;);

        /*
        * Additionnal global processing
        */
    }
}
</code></pre></pre>
<p>With that in place, we can now proceed to the final core concept of the protocol: the globals
and the registry.</p>
<h1><a class="header" href="#the-registry-and-globals" id="the-registry-and-globals">The registry and globals</a></h1>
<p>The Wayland protocol is designed in a modular fashion: all capabilities proposed by
the server to clients are each represented by modules, that are called &quot;globals&quot; in
the Wayland jargon.</p>
<p>A global is a blueprint advertized by the Wayland server to its clients, that the
client can instanciate into a Wayland protocol object, which will expose the
appropriate requests and events for interacting with the capability they represent.
This process of advertizing and instanciating is done with an other special
protocol object: the registry.</p>
<h2><a class="header" href="#the-registry" id="the-registry">The registry</a></h2>
<p>The registry is a protocol object with interface <code>wl_registry</code>. It is created from
an attached <code>wl_display</code> via its
<a href="https://docs.rs/wayland-client/*/wayland_client/protocol/wl_display/struct.WlDisplay.html#method.get_registry"><code>get_registry()</code></a>
method. Upon creation, the server will send it a stream of events telling the client
about which globals are available.</p>
<p>A global advertisement is composed of 3 values:</p>
<ul>
<li>the global name, an <code>u32</code> identifier which represents the global within the globals list
(it is <em>not</em> the same thing as the protocol id of the objects created by instanciating this
global)</li>
<li>the global interface, a string containing the name of the interface of the protocol objects
created from this global</li>
<li>the global version, an <code>u32</code> greater or equal to 1, which is used for protocol versionning</li>
</ul>
<p>The Wayland protocol can evolve, and the interfaces are versionned. The number the server sends
is the highest version it supports. The server must support all lower versions as well.</p>
<p>Upon receiving this list, the client can then instanciate the globals it whishes to use into
protocol objects using the
<a href="https://docs.rs/wayland-client/0.27.0/wayland_client/protocol/wl_registry/struct.WlRegistry.html#method.bind"><code>bind</code></a>
method of the registry.</p>
<h2><a class="header" href="#the-two-kinds-of-globals" id="the-two-kinds-of-globals">The two kinds of globals</a></h2>
<p>The various globals that a Wayland server can advertize can be roughtly classified in two kinds,
depending on whether they can be advertized multiple times by the server.</p>
<p><em>Singleton globals</em> represent a capability of the compositor. This is something the Wayland server
makes possible for clients to do. They generally exist from the start, never change and are
advertized only once.</p>
<p><em>Multi globals</em> however represent some device the server has access to. For example a monitor,
or an input device. These globals can thus exist with multiplicity. For example, the
server will advertized one <code>wl_output</code> global for each monitor that is plugged in the computer,
each with a different <code>name</code>. Furthermore, these globals can appear or dissapear during the
lifetime of the app, as such devices are plugged in or out.</p>
<p>The registry <code>Global</code> event signals a new global, while its <code>GlobalRemove</code> event signals that a
given global has been removed. When a such a global is removed, all the protocol objects derived
from it will generally become inert, and the client is then expected to do cleanup by destroying
them using the appropriate requests.</p>
<h2><a class="header" href="#the-globalmanager" id="the-globalmanager">The GlobalManager</a></h2>
<p>Tracking the list of globals, their versions, and instanciating them requires some work that can be
automated away, as such, <code>wayland-client</code> provides an abstraction which simplifies this work for you,
the <a href="https://docs.rs/wayland-client/0.27.0/wayland_client/struct.GlobalManager.html"><code>GlobalManager</code></a>.
SCTK further provides other abstractions on top of it, for more convenience, which will be presented
in the following sections. The rest of the client-side half of book will be dedicated to understanding
the different globals and how to use them.</p>
<p>Before jumping to that, lets put all this together with a small app that connects to the wayland server,
receives the list of globals, and prints them to the console:</p>
<pre><pre class="playground"><code class="language-rust">use wayland_client::{Display, GlobalManager};

fn main() {
    // Connect to the server
    let display = Display::connect_to_env().unwrap();

    // Create the event queue
    let mut event_queue = display.create_event_queue();
    // Attach the display
    let attached_display = display.attach(event_queue.token());

    // We use the GlobalManager convenience provided by the crate, it covers
    // most classic use cases and avoids us the trouble to manually implement
    // the registry
    let globals = GlobalManager::new(&amp;attached_display);

    // sync_roundtrip is a special kind of dispatching for the event queue.
    // Rather than just blocking once waiting for replies, it'll block
    // in a loop until the server has signalled that it has processed and
    // replied accordingly to all requests previously sent by the client.
    //
    // In our case, this allows us to be sure that after this call returns,
    // we have received the full list of globals.
    event_queue.sync_roundtrip(
        // we don't use a global state for this example
        &amp;mut (),
        // The only object that can receive events is the WlRegistry, and the
        // GlobalManager already takes care of assigning it to a callback, so
        // we cannot receive orphan events at this point
        |_, _, _| unreachable!()
    ).unwrap();

    // GlobalManager::list() provides a list of all globals advertized by the
    // server
    println!(&quot;Available globals:&quot;);
    for (name, interface, version) in globals.list() {
        println!(&quot;{}: {} (version {})&quot;, name, interface, version);
    }
}
</code></pre></pre>
<h1><a class="header" href="#wayland-compositors" id="wayland-compositors">Wayland Compositors</a></h1>
<p>Work in Progress.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
