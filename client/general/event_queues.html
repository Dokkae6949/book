<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Event queues and dispatching - The Smithay Handbook</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../client/intro.html"><strong aria-hidden="true">1.</strong> Wayland apps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/general/intro.html"><strong aria-hidden="true">1.1.</strong> General principles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/general/objects.html"><strong aria-hidden="true">1.1.1.</strong> Objects</a></li><li class="chapter-item expanded "><a href="../../client/general/event_queues.html" class="active"><strong aria-hidden="true">1.1.2.</strong> Event queues and dispatching</a></li><li class="chapter-item expanded "><a href="../../client/general/initializing.html"><strong aria-hidden="true">1.1.3.</strong> Initializing an app</a></li><li class="chapter-item expanded "><a href="../../client/general/registry.html"><strong aria-hidden="true">1.1.4.</strong> The registry and globals</a></li></ol></li><li class="chapter-item expanded "><a href="../../client/sctk/intro.html"><strong aria-hidden="true">1.2.</strong> Getting started with SCTK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/sctk/environment.html"><strong aria-hidden="true">1.2.1.</strong> The Environment</a></li><li class="chapter-item expanded "><a href="../../client/sctk/window.html"><strong aria-hidden="true">1.2.2.</strong> Creating a Window</a></li><li class="chapter-item expanded "><a href="../../client/sctk/drawing.html"><strong aria-hidden="true">1.2.3.</strong> Drawing to a Window</a></li><li class="chapter-item expanded "><a href="../../client/sctk/image_viewer.html"><strong aria-hidden="true">1.2.4.</strong> Exercise: an image viewer</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.</strong> Processing user input</li><li><ol class="section"><li class="chapter-item expanded "><strong aria-hidden="true">1.3.1.</strong> The seats</li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.2.</strong> Pointers</li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.3.</strong> Keyboards</li><li class="chapter-item expanded "><strong aria-hidden="true">1.3.4.</strong> Touchscreens</li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">1.4.</strong> Multiple outputs and HiDPI</li><li class="chapter-item expanded "><strong aria-hidden="true">1.5.</strong> Cliboard and Drag'n'Drop</li><li class="chapter-item expanded "><strong aria-hidden="true">1.6.</strong> Drawing with OpenGL</li></ol></li><li class="chapter-item expanded "><a href="../../server/intro.html"><strong aria-hidden="true">2.</strong> Wayland Compositors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Smithay Handbook</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#event-queues-and-dispatching" id="event-queues-and-dispatching">Event queues and dispatching</a></h1>
<p>If the <a href="https://docs.rs/wayland-client/latest/wayland_client/struct.Connection.html"><code>Connection</code></a> is the heart of your Wayland app, the <a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a> will be its
backbone. As described in the previous section, messages are sent in both directions,
and so far we only discussed how to send requests (using the methods of proxies),
but not how to receive events. This is done via a dispatching mechanism powered by the
event queues.</p>
<h2><a class="header" href="#state-and-dispatching" id="state-and-dispatching">State and dispatching</a></h2>
<p>Generally, an app built using <code>wayland-client</code> will be structured as a central type,
which we refer to as the <em>state</em> of the app. This type needs to provide several methods
that are used as callbacks by <code>wayland-client</code> to deliver events from the server.</p>
<p>Providing these methods is done by implementing the <a href="https://docs.rs/wayland-client/latest/wayland_client/trait.Dispatch.html"><code>Dispatch</code></a> trait on your state. This
is a parametric trait with two type parameters: the first one is a Wayland interface, and
the second is the type of the user data you want to associate with this kind of object.</p>
<p>For example, to handle events sent to a <code>WlSurface</code> object, with user data <code>MyUserData</code>, you
would provide the following implementation:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Dispatch&lt;WlSurface, MyUserData&gt; for Mystate {
    fn event(
        state: &amp;mut Self,
        proxy: &amp;WlSurface,
        event: &lt;WlSurface as Proxy&gt;::Event,
        data: &amp;MyUserData,
        conn: &amp;Connection
        qhandle: &amp;QueueHandle&lt;MyState&gt;
    ) {
        /*
         * Here is your logic for handling the event
         */
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's explain the arguments of this method one by one:</p>
<ol>
<li>As you can see, the method does not take <code>&amp;mut Self</code> as argument, but instead <code>state: &amp;mut Self</code>. This is
related to a mechanism of <code>wayland-client</code> that allows composition by delegating <code>Dispatch</code> implementations
to fields of your state struct. This is detailed below.</li>
<li>The second argument is a proxy representing the Wayland object with which this event is associated</li>
<li>The first argument is an enum representing the content of the event. You are thus expected to match it
in order to process it.</li>
<li>The fourth argument is a reference to the user data associated with this object.</li>
<li>The fifth argument is a reference to the underlying <a href="https://docs.rs/wayland-client/latest/wayland_client/struct.Connection.html"><code>Connection</code></a>. Most of the time you will not need to
use it, but it some circumstances it can be needed.</li>
<li>The last argument is a handle to the [<code>EventLoop</code>] currently handling this object. You will need it if you
want to invoke requests that create new objects.</li>
</ol>
<p>Note that the event enums are marked as <code>#[non_exhaustive]</code>, as new events can be introduced in later
revisions of the Wayland protocol. The Wayland protocol has a versioning system for objects (which this is
details later in this book), as a result your app will not receive these new events unless you explicitly opt
in by requiring a higher version from the server. Nevertheless, <code>wayland-client</code> still needs to statically
support them. These enums being non-exhaustive thus allows the crate to handle new versions of the protocol
without it being a breaking change.</p>
<p>As a result, when you implement the <a href="https://docs.rs/wayland-client/latest/wayland_client/trait.Dispatch.html"><code>Dispatch</code></a> trait you need to keep an eye on which version of the object
you're going to work with, and construct your match accordingly. Having a catch-all <code>_ =&gt; unreachable!()</code> arm
is here an easy way to ensure you are not ignoring events that you can actually receive.</p>
<p>Another important point no note is that the <a href="https://docs.rs/wayland-client/latest/wayland_client/trait.Dispatch.html"><code>Dispatch</code></a> trait is parameterized by the user data type. This
means that you can provide two different implementations for the same Wayland interface, and the event queue
will invoke one or the other depending on which type of user data was provided when the object was created.</p>
<h2><a class="header" href="#event-queues" id="event-queues">Event queues</a></h2>
<p>In some cases however, having a single state may be limiting. Some apps have their logic clearly separated in
independent parts, and may want to have these parts run concurrently on multiple threads. To handle this,
<code>wayland-client</code> has a concept of <a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a>. Most apps will be fine with a single event queue, but the
principle is the same with one or more.</p>
<p>Event queues are created from the <a href="https://docs.rs/wayland-client/latest/wayland_client/struct.Connection.html"><code>Connection</code></a> with the <a href="https://docs.rs/wayland-client/latest/wayland_client/struct.Connection.html#method.new_event_queue"><code>Connection::new_event_queue()</code></a> method. Both this
method and the <a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a> struct have a type parameter, which is the type of your state struct. This means
that an event queue can only be used with a single type as state. This allows <code>wayland-client</code> to statically
ensure that your app provides all the needed <a href="https://docs.rs/wayland-client/latest/wayland_client/trait.Dispatch.html"><code>Dispatch</code></a> implementations.</p>
<p>Once the event queue is created, you can retrieve its handle with the <a href="https://docs.rs/wayland-client/0.30.2/wayland_client/struct.EventQueue.html#method.handle"><code>EventQueue::handle()</code></a> method. This
handle is required by all methods that create a new Wayland object, and allows you to specify which event queue
(and thus which state) should handle the events for this object.</p>
<p>For a simple app where the Wayland connection is the only source of events to process, the main structure of
the program would then look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wayland_client::Connection;

let connection = Connection::connect_to_env().unwrap();
let mut event_queue = connection.new_event_queue();

/*
 * Here the initialization code of your app...
 */

// And the main loop:
//
// This assumes that the `state` struct contains an `exit` boolean field, that is
// set to true when the app decided it should exit.
while !state.exit {
    event_queue.blocking_dispatch(&amp;mut state).expect(&quot;Wayland connection lost!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://docs.rs/wayland-client/0.30.2/wayland_client/struct.EventQueue.html#method.blocking_dispatch"><code>EventQueue::blocking_dispatch()</code></a> method will put your app to sleep and wait until new events from the
server are available, dispatch them to the appropriate <a href="https://docs.rs/wayland-client/latest/wayland_client/trait.Dispatch.html"><code>Dispatch</code></a> methods of the <code>state</code>, and then return.</p>
<p>If it returns an error, then the Wayland connection has already been closed and can no longer be used. This
would typically happen in two main situations: either your app triggered a protocol error and the connection
was killed by the server, or the server has shut down.</p>
<p>While this simple structure is sufficient for this introduction, more advanced programs generally don't want
to just sleep waiting for events. For example a game or a video player needs to continue to update its
contents even if no event occurs. <a href="https://docs.rs/wayland-client/*/wayland_client/struct.EventQueue.html"><code>EventQueue</code></a> provides other methods to dispatch events in a non-blocking
way, see its API documentation for more details.</p>
<h2><a class="header" href="#dispatch-delegation" id="dispatch-delegation">Dispatch delegation</a></h2>
<p><code>wayland-client</code> also provides means to provide a generic implementation of <a href="https://docs.rs/wayland-client/latest/wayland_client/trait.Dispatch.html"><code>Dispatch</code></a> that downstream
crates or modules may use in a composition-like fashion. SCTK heavily uses this mechanism to provide generic
and modular helpers, so while you'll probably not need to <em>implement</em> such helpers at first, it is important
to have a general idea of how they work to use them.</p>
<p>The general structure of this mechanism is as follows:</p>
<ol>
<li>You provide a sub-state type that contains the data necessary to handle the events of the subset of
interfaces your helper should manage.</li>
<li>You provide generic implementations of the <a href="https://docs.rs/wayland-client/latest/wayland_client/trait.Dispatch.html"><code>Dispatch</code></a> trait on this sub-state type, by explicitly making
its third type parameter as generic (rather than letting it default to <code>Self</code>)</li>
<li>The downstream module will then have your sub-state as a field of its state struct, and use the
<a href="https://docs.rs/wayland-client/0.30.2/wayland_client/macro.delegate_dispatch.html"><code>delegate_dispatch!</code></a> macro to delegate its <a href="https://docs.rs/wayland-client/latest/wayland_client/trait.Dispatch.html"><code>Dispatch</code></a> implementation to your helper.</li>
</ol>
<p>See the API documentation of <a href="https://docs.rs/wayland-client/latest/wayland_client/trait.Dispatch.html"><code>Dispatch</code></a> and <a href="https://docs.rs/wayland-client/0.30.2/wayland_client/macro.delegate_dispatch.html"><code>delegate_dispatch!</code></a> for more details and examples.</p>
<p>With all this context given, we are now ready to initialize our first app!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../client/general/objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../client/general/initializing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../client/general/objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../client/general/initializing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
